from django.db import models, transaction
from django.shortcuts import get_object_or_404
from rest_framework import generics, status
from rest_framework.response import Response
from rest_framework.views import APIView

from authoring.models import Module, Step
from django.db.models import F
import re
from authoring.serializers.module_serializers import ModuleSerializer, StepSerializer
from authoring.services.publish_service import publish_module


class ModuleCreateView(generics.ListCreateAPIView):
    queryset = Module.objects.all()
    serializer_class = ModuleSerializer


class ModuleDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Module.objects.all()
    serializer_class = ModuleSerializer


class StepCreateView(generics.CreateAPIView):
    serializer_class = StepSerializer

    def perform_create(self, serializer):
        module = get_object_or_404(Module, pk=self.kwargs["module_id"])
        last_index = module.steps.aggregate(max_idx=models.Max("order_index")).get("max_idx") or 0
        serializer.save(module=module, order_index=last_index + 1)


class StepUpdateDeleteView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Step.objects.all()
    serializer_class = StepSerializer
    
    def perform_destroy(self, instance: Step):
        # Ensure subsequent steps shift up to fill the gap when a step is deleted
        # and update titles that were auto-generated ("Step <n>") to reflect new indices.
        module = instance.module
        current_index = instance.order_index
        # capture affected steps (those after the deleted one) so we can update titles
        affected = list(
            Step.objects.filter(module=module, order_index__gt=current_index).values("pk", "order_index", "title")
        )
        with transaction.atomic():
            # delete the instance first
            instance.delete()
            # decrement order_index for steps after the deleted one
            Step.objects.filter(module=module, order_index__gt=current_index).update(order_index=F("order_index") - 1)
            # update titles for steps that previously had autogenerated titles like "Step <n>"
            auto_re = re.compile(r"^\s*Step\s+(\d+)\s*$", re.IGNORECASE)
            for row in affected:
                title = (row.get("title") or "").strip()
                if not title:
                    continue
                m = auto_re.match(title)
                if not m:
                    continue
                old_idx = int(m.group(1))
                new_idx = old_idx - 1
                # set new title to match new index
                Step.objects.filter(pk=row["pk"]).update(title=f"Step {new_idx}")


class StepReorderView(APIView):
    def post(self, request, module_id):
        module = get_object_or_404(Module, pk=module_id)
        ordered_ids = request.data.get("orderedStepIds", [])
        step_ids = [str(s.id) for s in module.steps.all()]
        if len(ordered_ids) != len(step_ids) or set(ordered_ids) != set(step_ids):
            return Response({"detail": "orderedStepIds must match module steps"}, status=status.HTTP_400_BAD_REQUEST)
        with transaction.atomic():
            for idx, step_id in enumerate(ordered_ids):
                Step.objects.filter(pk=step_id, module=module).update(order_index=idx + 1)
        return Response({"detail": "reordered"}, status=status.HTTP_200_OK)


class ModulePublishView(APIView):
    def post(self, request, module_id):
        module = get_object_or_404(Module, pk=module_id)
        try:
            published = publish_module(module)
        except ValueError as exc:
            return Response({"detail": str(exc)}, status=status.HTTP_400_BAD_REQUEST)
        # If the publish service attached a json_url, convert to absolute URL for response
        json_url = getattr(published, "json_url", None)
        if json_url:
            if json_url.startswith("http://") or json_url.startswith("https://"):
                url = json_url
            else:
                url = request.build_absolute_uri(json_url)
        else:
            url = None
        resp = {"id": str(published.id), "version": published.version}
        if url:
            resp["url"] = url
        return Response(resp, status=status.HTTP_201_CREATED)


class ModuleRuntimeView(APIView):
    def get(self, request, module_id):
        module = get_object_or_404(Module, pk=module_id)
        latest = module.published_versions.order_by("-version").first()
        if not latest:
            return Response({"detail": "Module not yet published"}, status=status.HTTP_404_NOT_FOUND)
        return Response(latest.payload, status=status.HTTP_200_OK)
